name: Package Size Test - v2

on:
  workflow_dispatch:
    inputs:
      CONFIG_BASE_VERSION:
        description: '基准配置版本(clean|basic|func|test)'
        required: false
        default: 'clean'
      Test_per_Job_Limit:
        description: '单作业最大测试数（免费用户最大并行作业数为20）'
        required: false
        default: '10'

env:
  REPO_URL: https://github.com/coolsnowwolf/lede
  REPO_BRANCH: master
  FEEDS_CONF: feeds.conf.default
  CONFIG_FILE: .config
  DIY_P1_SH: diy-part1.sh
  DIY_P2_SH: diy-part2.sh
  TZ: Asia/Shanghai
  CONFIG_BASE_VERSION: ${{ github.event.inputs.CONFIG_BASE_VERSION }}
  SEQ_FILENAME: TestSequence.txt

jobs:
  Factory:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.json_content }}
      TimeStamp: ${{ steps.info.outputs.TimeStamp }}
    steps:
      - uses: actions/checkout@main

      - name: List Test Sequence
        id: info
        run: |
          # 时间戳，组成Artifact的文件名
          date +"%Y%m%d%H%M"
          echo "::set-output name=TimeStamp::$(date +"%Y%m%d%H%M")"
          # 打印序列信息和目录
          echo '====================序列内容===================='
          cat ${{ env.SEQ_FILENAME }} -An
          echo '====================测试目录===================='
          grep '@' ${{ env.SEQ_FILENAME }} -n | cat -n

      # 分任务
      - name: Assign jobs
        id: set-matrix
        run: |
          # 分析列表
          lines_num=$(wc -l ${{ env.SEQ_FILENAME }} | cut -f1 -d' ')
          tests_num=$(grep '@' ${{ env.SEQ_FILENAME }} -c)
          title_line_num_list=($(grep '@' ${{ env.SEQ_FILENAME }} -n | cut -d: -f1))
          # 输出分析结果
          echo "测试序列：共${lines_num}行，包含${tests_num}条测试任务"
          echo '====================标题清单===================='
          echo '（序列格式： [序号] 标题所在行行号 ）'
          for i in $(seq ${tests_num}); do
            echo -n "[$i] ${title_line_num_list[i-1]}"
          done
          echo

          # 根据单作业最大测试数，计算总作业数及每个作业分配的测试数
          Test_per_Job_Limit=${{ github.event.inputs.Test_per_Job_Limit }}
          if [ $(( tests_num % Test_per_Job_Limit )) -eq 0 ]; then
            # 可平均分配
            job_num=$((tests_num/Test_per_Job_Limit))
            tests_per_job=${Test_per_Job_Limit}
          else
            # 非平均分配
            job_num=$((tests_num/Test_per_Job_Limit+1))
            if [ $(( tests_num % job_num )) -eq 0 ]; then
              tests_per_job=$((tests_num/job_num))
            else
              tests_per_job=$((tests_num/job_num+1))
            fi
          fi
          spliter_seq=($(seq 1 ${tests_per_job} ${tests_num})) # job的起始test编号
          spliter_seq[job_num]=$((tests_num+1))                # 为循环补充一个开点

          # 生成job matrix，配置格式为json | 同时打印日志
          # {
          #     "include":[
          #         {
          #             "SEQ_ID":"1",
          #             "sed_script":"1,11p",
          #             "test_cnt_init":"1"
          #         },...
          #     ]
          # }
          json_content='{"include":['
          echo "${tests_num} 条测试任务分 ${job_num} 个作业并行，分工依次为："
          for i in $(seq 1 ${job_num}); do
            job_no_from=${spliter_seq[i-1]}
            job_no_to=$((spliter_seq[i]-1))
            seq_line_from=${title_line_num_list[job_no_from-1]}
            seq_line_to=$((title_line_num_list[job_no_to]-1))
            [[ $seq_line_to -eq -1 ]] && seq_line_to=${lines_num} # 越界返回0，打个补丁
            sed_script="${seq_line_from},${seq_line_to}p"
            echo "[Job $i]Test ${job_no_from}-${job_no_to}" "|" "行号：${sed_script}"
            json_content="${json_content}{\"SEQ_ID\":\"${i}\",\"sed_script\":\"${sed_script}\",\"test_cnt_init\":\"${job_no_from}\"},"
          done
          # 去掉最后一个逗号，然后封底
          json_content=${json_content%?}']}'
          echo "[json_content] ${json_content}"
          # 输出到output交给SEQs-strategy-matrix
          echo "::set-output name=json_content::${json_content}"

  Workers:
    runs-on: ubuntu-20.04
    needs: Factory
    strategy:
      matrix: ${{fromJSON(needs.Factory.outputs.matrix)}}
    env:
      SEQ_ID: ${{ matrix.SEQ_ID }}
      sed_script: ${{ matrix.sed_script }}
      test_cnt_init: ${{ matrix.test_cnt_init }}

    steps:
      - uses: actions/checkout@main

      - name: Read Job Sequence
        run: |
          # 依据作业分配到的行号，截取对应序列输出到文件
          sed -n ${sed_script} ${SEQ_FILENAME} > JobTest.list
          # 打印序列信息和目录
          echo "====================作业${SEQ_ID}测试序列(${sed_script})===================="
          cat JobTest.list -An
          echo "====================测试目录(计数器初始值为${test_cnt_init})===================="
          grep '@' JobTest.list -n | cat -n

      - name: Initialize environment
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          sudo rm -rf /etc/apt/sources.list.d/* /usr/share/dotnet /usr/local/lib/android /opt/ghc
          sudo -E apt-get -qq update
          sudo -E apt-get -qq install $(curl -fsSL git.io/depends-ubuntu-2004)
          sudo -E apt-get -qq autoremove --purge
          sudo -E apt-get -qq clean
          docker image prune -a -f
          sudo timedatectl set-timezone "$TZ"
          sudo mkdir -p /workdir
          sudo chown $USER:$GROUPS /workdir

      - name: Clone source code
        working-directory: /workdir
        run: |
          git clone $REPO_URL -b $REPO_BRANCH openwrt
          ln -sf /workdir/openwrt $GITHUB_WORKSPACE/openwrt
          echo "[Check disk usage]"
          df -hT .
          echo "[Check space usage] $PWD"
          du -h --max-depth=2

      - name: Load custom feeds
        run: |
          [ -e $FEEDS_CONF ] && mv $FEEDS_CONF openwrt/feeds.conf.default
          chmod +x $DIY_P1_SH
          cd openwrt
          $GITHUB_WORKSPACE/$DIY_P1_SH

      - name: Update & Install feeds
        working-directory: /workdir/openwrt
        run: |
          ./scripts/feeds update -a
          ./scripts/feeds install -a
          echo "[Check disk usage]"
          df -hT .
          echo "[Check space usage] $PWD"
          du -h --max-depth=1

      - name: Download All package
        id: download
        run: |
          [ -e files ] && mv files openwrt/files
          # [ -e $CONFIG_FILE ] && mv $CONFIG_FILE openwrt/.config
          chmod +x $DIY_P2_SH

          cd openwrt
          $GITHUB_WORKSPACE/$DIY_P2_SH $CONFIG_BASE_VERSION           # 生成配置基准(.config baseline)
          cp .config clean.config                                     # 保留副本，每次编译都以此为起点
          sed -e '/[@#]/d' $GITHUB_WORKSPACE/JobTest.list >> .config  # 去掉标题(@开头)/不勾选(#开头)的行，增补到配置文件以下载全部内容
          make defconfig

          # 下载包，如若出错生成警告
          make download -j8 | tee make_download.log
          grep 'ERROR:' make_download.log | xargs -i echo "::warning:: [Download Try 1]" {}
          find dl -size -1024c -exec ls -l {} \;
          find dl -size -1024c -exec rm -f {} \;
          # 二次尝试
          grep 'ERROR:' -q make_download.log && make download -j1 V=s | tee make_download.log
          grep 'ERROR:' make_download.log | xargs -i echo "::warning:: [Download Try 2]" {}
          find dl -size -1024c -exec ls -l {} \;
          find dl -size -1024c -exec rm -f {} \;

          echo "[Check disk usage]"
          df -hT .
          echo "[Check space usage] $PWD"
          du -h --max-depth=1

      - name: Compile & Log filesize
        id: compile
        run: |
          cd openwrt
          # 从.config中截取型号信息
          # grep '^CONFIG_TARGET.*DEVICE.*=y' .config | sed -r 's/.*DEVICE_(.*)=y/\1/' > DEVICE_NAME
          # [ -s DEVICE_NAME ] && echo "DEVICE_NAME=_$(cat DEVICE_NAME)" >> $GITHUB_ENV

          # 测试序列预处理，去除win换行符中的CR(\r)，否则上传artifacts时会出错
          sed -i 's/\r//' "${GITHUB_WORKSPACE}/JobTest.list"
          # 按标题识别位点'@'切分测试序列，组合成一系列配置文件
          (mkdir config_seq; cd config_seq; csplit --prefix=patch "${GITHUB_WORKSPACE}/JobTest.list" /@/ {*} -sz)

          # 创建产物目录
          ARTIFACTS_DIR=$(mkdir ARTIFACTS_DIR; cd ARTIFACTS_DIR; pwd)
          echo "[ARTIFACTS_DIR]${ARTIFACTS_DIR}"
          echo "::set-output name=ARTIFACTS_DIR::${ARTIFACTS_DIR}"

          # 后台记录CPU占用
          uptime_log () { while :; do uptime >> $ARTIFACTS_DIR/uptime_log_${SEQ_ID}.log; sleep 30; done }
          uptime_log &

          test_no=$((test_cnt_init-1))                        # 轮次计数器初始化，因为一开始就++所以先-1
          for patch_file in config_seq/patch*
          do
            title=$(head $patch_file -n1)                     # 原汁原味的标题，保留所有特殊符号
            echo "[Test No.$((++test_no))] $title, start at $(date +"%Y-%m-%d %H:%M")"

            cp -f clean.config .config                        # 起点，重置为基准配置
            sed '/@/d' $patch_file | tee -a .config           # 去掉标题行，增写配置
            echo " ==============[Test $test_no].config=============="
            cat .config
            echo "==============================================="

            # 给测试起个名：测试序号+标题，例：1@ Clean
            TEST_NAME="${test_no}${title}"
            # 测试日志文件
            TEST_LOG_FILE="$ARTIFACTS_DIR/${TEST_NAME}.log"
            cp "$patch_file" "$TEST_LOG_FILE"
            echo "[TEST_LOG_FILE] ${TEST_LOG_FILE}"
            # 测试成品存放目录
            TEST_RESULT_DIR="$ARTIFACTS_DIR/${TEST_NAME}"
            mkdir "${TEST_RESULT_DIR}"
            echo "[TEST_RESULT_DIR] ${TEST_RESULT_DIR}"

            # 补全默认值，执行编译
            make defconfig
            echo "[Test ${test_no}] Try $(($(nproc)+1)) thread compile first"
              # try
              ( make -j $(($(nproc)+1)) || make -j1 || make -j1 V=s ) | tee -a "$TEST_LOG_FILE"
            # 根据第一节管道返回值判断编译结果
            if [ ${PIPESTATUS[0]} -ne 0 ]; then
              # except
              echo "[Test ${test_no}] Error(s) occurred during compile, please check..."
              touch ${TEST_RESULT_DIR}/is_failed
            else
              echo "[Test ${test_no}] Compile success..."
              echo 'in path ' ./bin/targets/*/*
              ls -lah ./bin/targets/*/*
              echo "==============================================="
              
              # 截取bytes换算为MB（精度-两位小数），记录到文件
              echo "[Test ${test_no}] Logging filesize..."
              du -ab --max-depth=1 ./bin/targets/*/* | awk '{printf "%8.2fM",$1/2^20; $1=""; print}' | tee "$ARTIFACTS_DIR/${TEST_NAME}.sizelog.txt"

              # 保留有用文件
              mv -v .config ./bin/targets/*/*/*.{buildinfo,manifest} "${TEST_RESULT_DIR}/"

              # 删除无用文件
              echo "[Test ${test_no}] Cleaning for the next round..."
              # rm ./bin/targets/*/*/*.bin ./bin/targets/*/*/sha256sums
              find ./bin/targets/*/* -maxdepth 1 -type f -exec rm -v {} \;  # 保留packages文件夹
              echo "[Test $test_no] --Finished--" $(date +"%Y-%m-%d %H:%M")
            fi
          done

          # 保留所有的ipk
          mv ./bin ${ARTIFACTS_DIR}/

          echo "[Check disk usage]"
          df -hT .
          echo "[Check space usage] $PWD"
          du -h --max-depth=1
          echo "------------------------End of Job------------------------"

      - name: Upload Artifact Directory
        uses: actions/upload-artifact@main
        # if: steps.compile.conclusion == 'success'
        with:
          name: SizeTest_${{ needs.Factory.outputs.TimeStamp }}
          path: ${{ steps.compile.outputs.ARTIFACTS_DIR }}

      - name: SSH Debug
        uses: mxschmitt/action-tmate@v3
        if: ${{ failure() }}

  delete-workflow-run:
    runs-on: ubuntu-latest
    needs: Workers
    if: ${{ always() }}
    steps:
      - uses: GitRML/delete-workflow-runs@main
        with:
          retain_days: 1
          keep_minimum_runs: 3
